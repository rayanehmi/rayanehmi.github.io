<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Portfolio - Rayane Hachemi</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #2c3e50; 
            font-family: 'Roboto', sans-serif;
            display: flex; 
            align-items: center;
            justify-content: center;
        }
        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #000;
            cursor: none;
        }
        #screen-info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background-color: rgba(20, 30, 40, 0.85);
            color: #ecf0f1;
            border-radius: 8px;
            font-size: clamp(0.8em, 1.5vw, 1.1em);
            font-family: 'Press Start 2P', cursive;
            text-align: center;
            z-index: 10;
            box-shadow: 0 3px 10px rgba(0,0,0,0.4);
            pointer-events: none;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.75);
            align-items: center;
            justify-content: center;
            cursor: default;
            padding: 20px; 
        }
        .modal-content {
            position: relative;
            background-color: #f1f1f1;
            color: #2c3e50;
            margin: auto;
            padding: 20px 30px;
            border: 2px solid #34495e;
            width: 90%;
            border-radius: 10px;
            text-align: left;
            font-family: 'Roboto', sans-serif;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            max-height: 80vh; 
            overflow-y: auto; 
        }
        .modal-content .md-content img {
            max-width: 100%;
            height: auto;
        }
        .close-button {
            position: absolute;
            top: 10px;
            right: 20px;
            color: #e74c3c; /* The same red color */
            font-size: 28px;
            font-weight: bold;
            line-height: 1;
            cursor: pointer;
            transition: color 0.2s;
        }
        .close-button:hover {
            color: #c0392b; /* Darker red on hover */
        }
        .modal-content h3 {
            font-family: 'Press Start 2P', cursive;
            color: #e74c3c;
            margin-top: 0;
            font-size: 1.2em;
        }
        .modal-content p {
            font-size: 1em;
            line-height: 1.6;
        }
        .modal-content button {
            font-family: 'Press Start 2P', cursive;
            background-color: #e74c3c;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
            font-size: 0.8em;
            transition: background-color 0.2s;
            display: block; 
            margin-left: auto;
            margin-right: auto;
        }
        .modal-content button:hover {
            background-color: #c0392b;
        }
        
        /** ADDED: Styling for Markdown-generated HTML in the modal **/
        .modal-content .md-content h1, .modal-content .md-content h2, .modal-content .md-content h3 {
            font-family: 'Press Start 2P', cursive;
            color: #34495e;
            margin-top: 24px;
            margin-bottom: 10px;
        }
        .modal-content .md-content h1 { font-size: 1.3em; }
        .modal-content .md-content h2 { font-size: 1.1em; }
        .modal-content .md-content h3 { font-size: 1.0em; }
        .modal-content .md-content a {
            color: #2980b9;
            text-decoration: none;
            font-weight: bold;
        }
        .modal-content .md-content a:hover {
            text-decoration: underline;
        }
        .modal-content .md-content code {
            background-color: #e3e6e8;
            padding: 2px 5px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
            border: 1px solid #bdc3c7;
        }
        .modal-content .md-content pre {
            background-color: #e3e6e8;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid #bdc3c7;
        }
         .modal-content .md-content pre code {
            border: none;
            background-color: transparent;
            padding: 0;
        }
        .modal-content .md-content ul, .modal-content .md-content ol {
            padding-left: 25px;
        }
         .modal-content .md-content li {
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="screen-info">Loading...</div>
    </div>

    <div id="messageModal" class="modal">
        <div class="modal-content">
            <span id="modalCloseX" class="close-button">&times;</span>
            <h3 id="modalTitle">Notification</h3>
            <div id="modalMessageText"></div>
            <button id="modalCloseButton">CLOSE</button>
        </div>
    </div>

    <script>
        // --- SCRIPT (MOSTLY UNCHANGED, with key modifications noted) --- //
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const player = { width: 20, height: 20, x: 0, y: 0, color: '#2ecc71', outlineColor: '#27ae60', orientationDx: 0, orientationDy: -1, prevMouseX: 0, prevMouseY: 0 };
        const world = [ [ { color: '#1f2c38', name: "Forbidden Zone Alpha", type: 'placeholder' }, { color: '#1f2c38', name: "Forbidden Zone Beta", type: 'placeholder' }, { color: '#1f2c38', name: "Forbidden Zone Gamma", type: 'placeholder' } ], [ { color: '#4a6b82', name: "Skills & Projects", type: 'skills_projects', shortName: "Skills" }, { color: '#34495e', name: "Welcome - Rayane Hachemi", type: 'presentation', shortName: "Home" }, { color: '#dde4e8', name: "My Blog", type: 'blog', shortName: "Blog" } ], [ { color: '#1f2c38', name: "Forbidden Zone Delta", type: 'placeholder' }, { color: '#212f3c', name: "Retro Arcade", type: 'game_zone', shortName: "Arcade" }, { color: '#1f2c38', name: "Forbidden Zone Epsilon", type: 'placeholder' } ] ];
        let currentScreenX = 1; let currentScreenY = 1;
        const screenInfoElement = document.getElementById('screen-info');
        const messageModal = document.getElementById('messageModal');
        const modalTitleElement = document.getElementById('modalTitle');
        const modalMessageText = document.getElementById('modalMessageText');
        const modalCloseButton = document.getElementById('modalCloseButton');
        let currentInteractiveElements = [];
        let globalMouseX = 0; let globalMouseY = 0;
        const allowedScreenCoords = [ { x: 1, y: 1 }, { x: 0, y: 1 }, { x: 2, y: 1 }, { x: 1, y: 2 } ];
        function isScreenTransitionAllowed(toX, toY) { return allowedScreenCoords.some(coord => coord.x === toX && coord.y === toY); }
        function drawText(text, x, y, font, color, align = 'left', baseline = 'top') { ctx.font = font; ctx.fillStyle = color; ctx.textAlign = align; ctx.textBaseline = baseline; ctx.fillText(text, x, y); }
        function drawWrappedText(text, x, y, maxWidth, lineHeight, font, color, align = 'left') { ctx.font = font; ctx.fillStyle = color; ctx.textAlign = align; ctx.textBaseline = 'top'; const words = text.split(' '); let line = ''; let currentY = y; for (let n = 0; n < words.length; n++) { const testLine = line + words[n] + ' '; const metrics = ctx.measureText(testLine); const testWidth = metrics.width; if (testWidth > maxWidth && n > 0) { ctx.fillText(line, x, currentY); line = words[n] + ' '; currentY += lineHeight; } else { line = testLine; } } ctx.fillText(line, x, currentY); return currentY + lineHeight; }
        function drawRoundedRect(x, y, width, height, radius, fillColor, strokeColor = null, lineWidth = 2) { ctx.beginPath(); ctx.moveTo(x + radius, y); ctx.lineTo(x + width - radius, y); ctx.quadraticCurveTo(x + width, y, x + width, y + radius); ctx.lineTo(x + width, y + height - radius); ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height); ctx.lineTo(x + radius, y + height); ctx.quadraticCurveTo(x, y + height, x, y + height - radius); ctx.lineTo(x, y + radius); ctx.quadraticCurveTo(x, y, x + radius, y); ctx.closePath(); if (fillColor) { ctx.fillStyle = fillColor; ctx.fill(); } if (strokeColor) { ctx.strokeStyle = strokeColor; ctx.lineWidth = lineWidth; ctx.stroke(); } }
        
        let cachedSkills = null; // Will hold the array of skills
        let cachedProjects = null; // Will hold the array of projects

        // This is the corrected function. Please ensure it's in your script.
        async function loadSkillsAndProjectsData() {
            try {
                const [skillsResponse, projectsResponse] = await Promise.all([
                    fetch('documents/skills.md'),
                    fetch('documents/projects.md')
                ]);

                // --- Parse Skills ---
                const skillsText = await skillsResponse.text();
                cachedSkills = skillsText.split('\n')
                    .filter(line => line.trim().startsWith('- '))
                    .map(line => line.trim().substring(2).trim());

                // --- Parse Projects ---
                const projectsText = await projectsResponse.text();
                
                // This corrected line uses a Regular Expression to handle your exact file format.
                cachedProjects = projectsText.split(/\s*---\s*/) 
                    .map(projectBlock => {
                        if (!projectBlock.trim()) return null; // Ignore any empty blocks from trailing separators
                        const lines = projectBlock.trim().split('\n');
                        const titleLine = lines.shift(); 
                        const title = titleLine.replace('## ', '').trim();
                        const desc = lines.join('\n').trim();
                        return { title, desc };
                    }).filter(p => p); // Filter out any null (empty) results

            } catch (error) {
                console.error("Failed to load skills or projects data:", error);
                cachedSkills = ["Error loading skills."];
                cachedProjects = [{title: "Error", desc: "Could not load projects data."}];
            }
        }

        // MODIFIED: modalMessageText now accepts HTML directly
        function showModal(title, messageHTML) {
            modalTitleElement.textContent = title;
            modalMessageText.innerHTML = messageHTML;
            messageModal.style.display = 'flex';
            canvas.style.cursor = 'default';
        }
        modalCloseButton.onclick = () => { messageModal.style.display = 'none'; canvas.style.cursor = 'none'; };

        // --- Close modal by clicking the 'X' button ---
        document.getElementById('modalCloseX').onclick = () => {
            messageModal.style.display = 'none';
            canvas.style.cursor = 'none';
        };

        // --- Close modal by clicking on the background ---
        messageModal.addEventListener('click', (event) => {
            // If the clicked element is the modal container itself (the background)
            if (event.target === messageModal) {
                messageModal.style.display = 'none';
                canvas.style.cursor = 'none';
            }
        });

        function updateScreenInfo() { let screenData = world[currentScreenY][currentScreenX]; let screenName = screenData.name; screenInfoElement.textContent = screenName; }
        function clearCanvas() { ctx.fillStyle = world[currentScreenY][currentScreenX].color; ctx.fillRect(0, 0, canvas.width, canvas.height); }
        function drawPlayer() { ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.ellipse(player.x + player.width / 2, player.y + player.height + 2, player.width / 2, 4, 0, 0, 2 * Math.PI); ctx.fill(); ctx.fillStyle = player.color; ctx.fillRect(player.x, player.y, player.width, player.height); ctx.strokeStyle = player.outlineColor; ctx.lineWidth = 2; ctx.strokeRect(player.x, player.y, player.width, player.height); ctx.fillStyle = 'black'; const eyeSize = 3; const eyeOffset = 4; if (player.orientationDy < -0.5) { ctx.fillRect(player.x + eyeOffset, player.y + eyeOffset, eyeSize, eyeSize); ctx.fillRect(player.x + player.width - eyeOffset - eyeSize, player.y + eyeOffset, eyeSize, eyeSize); } else if (player.orientationDy > 0.5) { ctx.fillRect(player.x + eyeOffset, player.y + player.height - eyeOffset - eyeSize, eyeSize, eyeSize); ctx.fillRect(player.x + player.width - eyeOffset - eyeSize, player.y + player.height - eyeOffset - eyeSize, eyeSize, eyeSize); } else if (player.orientationDx < -0.5) { ctx.fillRect(player.x + eyeOffset, player.y + eyeOffset, eyeSize, eyeSize); ctx.fillRect(player.x + eyeOffset, player.y + player.height - eyeOffset - eyeSize, eyeSize, eyeSize); } else if (player.orientationDx > 0.5) { ctx.fillRect(player.x + player.width - eyeOffset - eyeSize, player.y + eyeOffset, eyeSize, eyeSize); ctx.fillRect(player.x + player.width - eyeOffset - eyeSize, player.y + player.height - eyeOffset - eyeSize, eyeSize, eyeSize); } else { ctx.fillRect(player.x + eyeOffset, player.y + eyeOffset, eyeSize, eyeSize); ctx.fillRect(player.x + player.width - eyeOffset - eyeSize, player.y + eyeOffset, eyeSize, eyeSize); } }
        function drawPresentationScreen() { currentInteractiveElements = []; const padding = canvas.width * 0.1; const contentWidth = canvas.width - 2 * padding; let yPos = canvas.height * 0.15; drawText("Welcome!", canvas.width / 2, yPos, `bold clamp(24px, 4vw, 40px) 'Press Start 2P'`, '#ecf0f1', 'center'); yPos += 70; const introText = "I am Rayane Hachemi, a creative and passionate Machine Learning Engineer. This personal website is still under construction (by Gemini). Feel free to explore it!"; yPos = drawWrappedText(introText, canvas.width / 2, yPos, contentWidth, 28, `clamp(16px, 2vw, 20px) 'Roboto'`, '#bdc3c7', 'center'); yPos += 50; const linkFont = `clamp(14px, 1.8vw, 18px) 'Press Start 2P'`; const linkColor = '#3498db'; const linkHoverColor = '#e74c3c'; const linkHeight = 40; const linkSpacing = 20; const links = [ { id: 'email', text: "EMAIL", action: 'open_link', url: 'mailto:rhmi@outlook.fr' }, { id: 'linkedin', text: "LINKEDIN", action: 'open_link', url: 'https://www.linkedin.com/in/rhmi/' }, { id: 'github', text: "GITHUB", action: 'open_link', url: 'https://github.com/rayanehmi' }, { id: 'cv', text: "DOWNLOAD CV", action: 'open_link', url: 'documents/cv.pdf' } ]; links.forEach(link => { ctx.font = linkFont; const textMetrics = ctx.measureText(link.text); const textWidth = textMetrics.width; const linkX = canvas.width / 2 - textWidth / 2; const isHovered = globalMouseX >= linkX && globalMouseX <= linkX + textWidth && globalMouseY >= yPos && globalMouseY <= yPos + linkHeight; drawText(link.text, canvas.width / 2, yPos + linkHeight / 2, linkFont, isHovered ? linkHoverColor : linkColor, 'center', 'middle'); currentInteractiveElements.push({ ...link, x: linkX, y: yPos, width: textWidth, height: linkHeight, isHovered }); yPos += linkHeight + linkSpacing; }); }
        function measureWrappedTextHeight(text, maxWidth, lineHeight, font) {
            // We need to set the context's font to get accurate measurements
            const originalFont = ctx.font;
            ctx.font = font;

            const words = text.split(' ');
            let line = '';
            let lineCount = 1; // Start with 1 line

            if (!text || words.length === 0) {
                return 0; // No text, no height
            }

            for (let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const metrics = ctx.measureText(testLine);
                if (metrics.width > maxWidth && n > 0) {
                    line = words[n] + ' ';
                    lineCount++;
                } else {
                    line = testLine;
                }
            }

            // Restore the original font to not affect other drawing operations
            ctx.font = originalFont;
            
            // Return the total height
            return lineCount * lineHeight;
        }
        
        function drawSkillsProjectsScreen() {
            currentInteractiveElements = [];
            const padding = canvas.width * 0.05;
            const titleFont = `bold clamp(22px, 3vw, 30px) 'Press Start 2P'`;
            const sectionTitleFont = `bold clamp(18px, 2.5vw, 24px) 'Press Start 2P'`;
            const itemFont = `clamp(14px, 1.8vw, 18px) 'Roboto'`;
            const textColor = '#ecf0f1';
            const highlightColor = '#f1c40f';
            let yPos = canvas.height * 0.1;

            drawText("Skills & Projects", canvas.width / 2, yPos, titleFont, textColor, 'center');
            yPos += 70;

            // --- Draw Skills from Cached Data ---
            let skillsX = padding;
            let skillsY = yPos;
            drawText("Skills:", skillsX, skillsY, sectionTitleFont, textColor);
            skillsY += 40;
            
            if (!cachedSkills) {
                drawText("Loading skills...", skillsX, skillsY, itemFont, textColor);
            } else {
                cachedSkills.forEach(skill => {
                    ctx.font = itemFont; 
                    const textMetrics = ctx.measureText(skill);
                    const skillWidth = textMetrics.width;
                    const skillHeight = 25; 
                    const textRenderY = skillsY + skillHeight / 2; 

                    const isHovered = globalMouseX >= skillsX && globalMouseX <= skillsX + skillWidth + 20 && 
                                    globalMouseY >= skillsY && globalMouseY <= skillsY + skillHeight;
                    
                    drawText(skill, skillsX + 20, textRenderY, itemFont, isHovered ? highlightColor : textColor, 'left', 'middle');
                    if(isHovered) drawText(">", skillsX, textRenderY, itemFont, highlightColor, 'left', 'middle');
                    currentInteractiveElements.push({ id: `skill_${skill}`, type: 'info', text: skill, x: skillsX, y: skillsY, width: skillWidth + 20, height: skillHeight, isHovered });
                    skillsY += 35;
                });
            }

            // --- Draw Projects with Dynamic Height ---
            let projectsX = canvas.width / 2 + padding / 2;
            let projectsY = yPos;
            drawText("Projects:", projectsX, projectsY, sectionTitleFont, textColor);
            projectsY += 40;

            if (!cachedProjects) {
                drawText("Loading projects...", projectsX, projectsY, itemFont, textColor);
            } else {
                const cardWidth = Math.min(canvas.width * 0.4, 400);
                const cardPadding = 15;
                const projectTitleFont = `bold clamp(16px, 2vw, 20px) 'Roboto'`;
                const projectDescFont = `clamp(12px, 1.5vw, 16px) 'Roboto'`;
                const projectDescLineHeight = 20;

                cachedProjects.forEach(proj => {
                    // --- Calculate Dynamic Height BEFORE drawing ---
                    const titleAreaHeight = 35; // Fixed space for the title and its margin
                    const descMaxWidth = cardWidth - (cardPadding * 2); // Use the full inner width for measuring
                    
                    // Use our new helper function to measure the description's height
                    const descriptionHeight = measureWrappedTextHeight(proj.desc, descMaxWidth, projectDescLineHeight, projectDescFont);

                    // Calculate the total height for this specific card
                    const dynamicCardHeight = cardPadding + titleAreaHeight + descriptionHeight + cardPadding;

                    // --- Now, draw everything using the calculated height ---
                    const isHovered = globalMouseX >= projectsX && globalMouseX <= projectsX + cardWidth &&
                                    globalMouseY >= projectsY && globalMouseY <= projectsY + dynamicCardHeight;
                    
                    drawRoundedRect(projectsX, projectsY, cardWidth, dynamicCardHeight, 10, 
                                    isHovered ? '#567a94' : '#405d72', isHovered ? highlightColor : '#6b8ea8');
                    
                    drawText(proj.title, projectsX + cardPadding, projectsY + cardPadding, projectTitleFont, textColor);
                    
                    // We use the adjusted maxWidth again for the actual drawing to get the padding right
                    drawWrappedText(proj.desc, projectsX + cardPadding, projectsY + cardPadding + 30, cardWidth - (cardPadding * 2.5), projectDescLineHeight, projectDescFont, '#bdc3c7');
                    
                    // Increment Y position by the dynamic height of the card we just drew
                    projectsY += dynamicCardHeight + 20;
                });
            }
        }
        const blogTextColor = '#2c3e50';
        const blogTitleColor = '#e74c3c';
        function drawBlogScreen() {
            currentInteractiveElements = [];
            const padding = canvas.width * 0.05;
            const titleFont = `bold clamp(22px, 3vw, 30px) 'Press Start 2P'`;
            const articleTitleFont = `bold clamp(18px, 2.2vw, 22px) 'Roboto'`;
            const articleMetaFont = `clamp(12px, 1.5vw, 14px) 'Roboto'`;
            let yPos = canvas.height * 0.1;
            drawText("My Blog Corner", canvas.width / 2, yPos, titleFont, blogTitleColor, 'center');
            yPos += 70;

            const articles = [
                { id: 'blog1', title: "Agentic LLMs in Gaming", date: "June 10, 2025", path: "documents/blog1.md" },
                { id: 'blog2', title: "Tutorial: How to create a superhuman computer virus", date: "June 10, 2025", path: "documents/blog2.md" }
            ];
            const articleCardWidth = Math.min(canvas.width * 0.8, 700); 
            const articleCardX = canvas.width / 2 - articleCardWidth / 2;
            articles.forEach(article => {
                const articleHeightEst = 80;
                const isHovered = globalMouseX >= articleCardX && globalMouseX <= articleCardX + articleCardWidth &&
                                  globalMouseY >= yPos && globalMouseY <= yPos + articleHeightEst;
                
                // This is the corrected line
                drawRoundedRect(articleCardX, yPos, articleCardWidth, articleHeightEst, 8, isHovered ? '#f8f9fa' : '#ffffff', isHovered ? blogTitleColor : '#bdc3c7');

                drawText(article.title, articleCardX + 20, yPos + 20, articleTitleFont, isHovered ? blogTitleColor : blogTextColor);
                drawText(article.date, articleCardX + 20, yPos + 50, articleMetaFont, '#7f8c8d');
                
                currentInteractiveElements.push({ ...article, type: 'blog_article', x: articleCardX, y: yPos, width: articleCardWidth, height: articleHeightEst, action: 'show_article', isHovered });
                yPos += articleHeightEst + 20;
            });
        }
        function drawGameZoneScreen() { currentInteractiveElements = []; const padding = canvas.width * 0.05; const titleFont = `bold clamp(20px, 2.8vw, 28px) 'Press Start 2P'`; const itemFont = `clamp(14px, 1.8vw, 18px) 'Roboto'`; const textColor = '#ecf0f1'; const highlightColor = '#e74c3c'; const listTitleFont = `bold clamp(15px, 1.9vw, 19px) 'Press Start 2P'`; let yPos = canvas.height * 0.1; drawText("Retro Arcade (under construction)", canvas.width / 2, yPos, titleFont, textColor, 'center'); yPos += 50; const gameScreenWidth = canvas.width * 0.45; const gameScreenHeight = canvas.height * 0.4; const gameScreenX = padding; const gameScreenY = yPos; drawRoundedRect(gameScreenX, gameScreenY, gameScreenWidth, gameScreenHeight, 10, '#000000', '#34495e'); drawText("Mini-Game Here", gameScreenX + gameScreenWidth/2, gameScreenY + gameScreenHeight/2, `bold 18px 'Press Start 2P'`, '#555', 'center', 'middle'); const gameListX = gameScreenX + gameScreenWidth + padding * 0.5; let gameListY = yPos; drawText("Select Game:", gameListX, gameListY, listTitleFont, textColor); gameListY += 35; const miniGames = [ { id: 'game1', title: "Astro Blaster", action: 'load_minigame' }, { id: 'game2', title: "Pixel Hopper", action: 'load_minigame' }, { id: 'game3', title: "Retro Drive", action: 'load_minigame' }, { id: 'game4', title: "Maze Crawler", action: 'load_minigame' } ]; const gameItemHeight = 30; const gameItemSpacing = 12; const gameListWidth = canvas.width - gameListX - padding; miniGames.forEach(game => { if (gameListY + gameItemHeight > gameScreenY + gameScreenHeight) return; ctx.font = itemFont; const textMetrics = ctx.measureText(game.title); const gameItemRenderWidth = Math.min(textMetrics.width + 20, gameListWidth - 10); const isHovered = globalMouseX >= gameListX && globalMouseX <= gameListX + gameItemRenderWidth && globalMouseY >= gameListY && globalMouseY <= gameListY + gameItemHeight; drawRoundedRect(gameListX, gameListY, gameItemRenderWidth, gameItemHeight, 5, isHovered ? 'rgba(255,255,255,0.1)' : 'transparent', isHovered ? highlightColor : 'transparent'); drawText(game.title, gameListX + 10, gameListY + gameItemHeight / 2, itemFont, isHovered ? highlightColor : textColor, 'left', 'middle'); currentInteractiveElements.push({ ...game, x: gameListX, y: gameListY, width: gameItemRenderWidth, height: gameItemHeight, action: 'load_minigame', isHovered }); gameListY += gameItemHeight + gameItemSpacing; }); let controlsY = gameScreenY + gameScreenHeight + 40; const buttonSize = Math.min(canvas.width * 0.05, 45); const buttonSpacing = 8; const dpadCenterX = gameScreenX + gameScreenWidth * 0.3; const dpadLayout = [ {id: 'd_up', text: "↑", x: dpadCenterX, y: controlsY }, {id: 'd_left', text: "←", x: dpadCenterX - buttonSize - buttonSpacing, y: controlsY + buttonSize + buttonSpacing }, {id: 'd_down', text: "↓", x: dpadCenterX, y: controlsY + 2 * (buttonSize + buttonSpacing) }, {id: 'd_right', text: "→", x: dpadCenterX + buttonSize + buttonSpacing, y: controlsY + buttonSize + buttonSpacing } ]; const actionBtnStartX = dpadCenterX + 2 * (buttonSize + buttonSpacing) + 35; const actionBtnY = controlsY + (buttonSize + buttonSpacing); const actionButtonsLayout = [ { id: 'btn_a', text: "A", x: actionBtnStartX, y: actionBtnY }, { id: 'btn_b', text: "B", x: actionBtnStartX + buttonSize + buttonSpacing, y: actionBtnY } ]; const allControlButtons = [...dpadLayout, ...actionButtonsLayout]; allControlButtons.forEach(btn => { const isHovered = globalMouseX >= btn.x && globalMouseX <= btn.x + (btn.width || buttonSize) && globalMouseY >= btn.y && globalMouseY <= btn.y + (btn.height || buttonSize); drawRoundedRect(btn.x, btn.y, buttonSize, buttonSize, 8, isHovered ? highlightColor : '#555', '#777'); drawText(btn.text, btn.x + buttonSize/2, btn.y + buttonSize/2, `bold ${buttonSize*0.45}px 'Press Start 2P'`, textColor, 'center', 'middle'); currentInteractiveElements.push({ ...btn, type: 'game_control', width: buttonSize, height: buttonSize, action: 'control_press', isHovered }); }); }
        function drawPlaceholderScreen() { currentInteractiveElements = []; const screenData = world[currentScreenY][currentScreenX]; drawText(screenData.name, canvas.width / 2, canvas.height / 2 - 30, `bold clamp(20px, 3vw, 28px) 'Press Start 2P'`, '#ecf0f1', 'center'); drawText("Inaccessible Zone", canvas.width / 2, canvas.height / 2 + 20, `clamp(16px, 2vw, 20px) 'Roboto'`, '#7f8c8d', 'center'); }
        function drawCurrentScreenContent() { const screenType = world[currentScreenY][currentScreenX].type; switch (screenType) { case 'presentation': drawPresentationScreen(); break; case 'skills_projects': drawSkillsProjectsScreen(); break; case 'blog': drawBlogScreen(); break; case 'game_zone': drawGameZoneScreen(); break; case 'placeholder': default: drawPlaceholderScreen(); break; } }
        function drawStaticTransitionLabels() { const labelFont = `bold clamp(12px, 1.6vw, 16px) 'Press Start 2P'`; const labelColor = '#bdc3c7'; const labelOffset = 25; if (currentScreenX === 1 && currentScreenY === 1) { if (isScreenTransitionAllowed(0, 1)) { const target = world[1][0]; drawText(`← ${target.shortName}`, labelOffset, canvas.height / 2, labelFont, labelColor, 'left', 'middle'); } if (isScreenTransitionAllowed(2, 1)) { const target = world[1][2]; drawText(`${target.shortName} →`, canvas.width - labelOffset, canvas.height / 2, labelFont, labelColor, 'right', 'middle'); } if (isScreenTransitionAllowed(1, 2)) { const target = world[2][1]; drawText(`↓ ${target.shortName}`, canvas.width / 2, canvas.height - labelOffset, labelFont, labelColor, 'center', 'bottom'); } } else if (currentScreenX === 0 && currentScreenY === 1) { if (isScreenTransitionAllowed(1, 1)) { const target = world[1][1]; drawText(`${target.shortName} →`, canvas.width - labelOffset, canvas.height / 2, labelFont, labelColor, 'right', 'middle'); } } else if (currentScreenX === 2 && currentScreenY === 1) { if (isScreenTransitionAllowed(1, 1)) { const target = world[1][1]; drawText(`← ${target.shortName}`, labelOffset, canvas.height / 2, labelFont, labelColor, 'left', 'middle'); } } else if (currentScreenX === 1 && currentScreenY === 2) { if (isScreenTransitionAllowed(1, 1)) { const target = world[1][1]; drawText(`↑ ${target.shortName}`, canvas.width / 2, labelOffset, labelFont, labelColor, 'center', 'top'); } } }
        
        function handleMouseMove(e) { const rect = canvas.getBoundingClientRect(); globalMouseX = e.clientX - rect.left; globalMouseY = e.clientY - rect.top; player.x = globalMouseX - player.width / 2; player.y = globalMouseY - player.height / 2; player.x = Math.max(0, Math.min(canvas.width - player.width, player.x)); player.y = Math.max(0, Math.min(canvas.height - player.height, player.y)); const dx = globalMouseX - player.prevMouseX; const dy = globalMouseY - player.prevMouseY; const dist = Math.sqrt(dx*dx + dy*dy); if (dist > 1) { player.orientationDx = dx / dist; player.orientationDy = dy / dist; } player.prevMouseX = globalMouseX; player.prevMouseY = globalMouseY; currentInteractiveElements.forEach(el => { el.isHovered = globalMouseX >= el.x && globalMouseX <= el.x + el.width && globalMouseY >= el.y && globalMouseY <= el.y + el.height; }); }

        function handleCanvasClick(e) {
            if (messageModal.style.display === 'flex') return;
            const clickX = globalMouseX; const clickY = globalMouseY;

            for (const el of currentInteractiveElements) {
                if (el.isHovered) {
                    switch (el.action) {
                        case 'open_link': 
                            window.open(el.url, '_blank'); 
                            return;

                        /**
                         * MODIFIED: This case now fetches and renders Markdown content.
                         */
                        case 'show_article':
                            // Show a loading state in the modal immediately
                            showModal(el.title, '<em>Loading content...</em>');

                            // Fetch the markdown file from the specified path
                            fetch(el.path)
                                .then(response => {
                                    if (!response.ok) { // Check if the file was found
                                        throw new Error(`File not found: ${response.statusText}`);
                                    }
                                    return response.text(); // Get the text from the file
                                })
                                .then(markdown => {
                                    // Use the 'marked' library to convert markdown to HTML
                                    const contentHtml = marked.parse(markdown);
                                    
                                    // Update the modal with the final, styled content
                                    modalMessageText.innerHTML = `<em>${el.date}</em><hr><div class="md-content">${contentHtml}</div>`;
                                })
                                .catch(error => {
                                    // If fetching fails, show an error message
                                    console.error('Error fetching or parsing article:', error);
                                    modalMessageText.innerHTML = `
                                        <p style="color: #c0392b;"><strong>Error:</strong> Could not load article.</p>
                                        <p>Please ensure the file <code>${el.path}</code> exists in your repository.</p>`;
                                });
                            return; // Exit the click handler

                        case 'control_press': 
                            showModal("Game Control", `Button "${el.text}" pressed! (Coming Soon)`); 
                            return;
                        case 'load_minigame': 
                            showModal("Loading Game", `Loading: ${el.title}... (Simulation)`); 
                            return;
                    }
                }
            }

            const edgeThreshold = 0.10; let nextPotentialX = currentScreenX; let nextPotentialY = currentScreenY;
            if (clickX < canvas.width * edgeThreshold && currentScreenX > 0) { nextPotentialX = currentScreenX - 1; } else if (clickX > canvas.width * (1 - edgeThreshold) && currentScreenX < world[0].length - 1) { nextPotentialX = currentScreenX + 1; } else if (clickY < canvas.height * edgeThreshold && currentScreenY > 0) { nextPotentialY = currentScreenY - 1; } else if (clickY > canvas.height * (1 - edgeThreshold) && currentScreenY < world.length - 1) { nextPotentialY = currentScreenY + 1; }
            if ((nextPotentialX !== currentScreenX || nextPotentialY !== currentScreenY) && isScreenTransitionAllowed(nextPotentialX, nextPotentialY)) {
                currentScreenX = nextPotentialX; currentScreenY = nextPotentialY;
                if (clickX < canvas.width * edgeThreshold) player.x = canvas.width - player.width - 1; else if (clickX > canvas.width * (1 - edgeThreshold)) player.x = 1; else player.x = clickX - player.width / 2;
                if (clickY < canvas.height * edgeThreshold) player.y = canvas.height - player.height - 1; else if (clickY > canvas.height * (1 - edgeThreshold)) player.y = 1; else player.y = clickY - player.height / 2;
                player.x = Math.max(0, Math.min(canvas.width - player.width, player.x)); player.y = Math.max(0, Math.min(canvas.height - player.height, player.y));
                player.prevMouseX = player.x + player.width / 2; player.prevMouseY = player.y + player.height / 2;
                updateScreenInfo(); currentInteractiveElements = [];
            }
        }

        function handleResize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; const currentCanvasCenterX = canvas.width / 2; const currentCanvasCenterY = canvas.height / 2; player.prevMouseX = currentCanvasCenterX; player.prevMouseY = currentCanvasCenterY; player.x = currentCanvasCenterX - player.width / 2; player.y = currentCanvasCenterY - player.height / 2; updateScreenInfo(); currentInteractiveElements = []; }
        function gameLoop() { clearCanvas(); drawCurrentScreenContent(); drawStaticTransitionLabels(); drawPlayer(); requestAnimationFrame(gameLoop); }
        function init() { 
            loadSkillsAndProjectsData();
            canvas.width = window.innerWidth; canvas.height = window.innerHeight; player.x = canvas.width / 2 - player.width / 2; player.y = canvas.height / 2 - player.height / 2; player.prevMouseX = player.x + player.width / 2; player.prevMouseY = player.y + player.height / 2; canvas.addEventListener('mousemove', handleMouseMove); canvas.addEventListener('click', handleCanvasClick); window.addEventListener('resize', handleResize); updateScreenInfo(); gameLoop(); 
        }
        window.onload = init;
    </script>
</body>
</html>